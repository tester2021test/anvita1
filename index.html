<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Fun Match Fixed</title>
<style>
  /* --- RESET & LAYOUT --- */
  body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100vh; /* Full viewport height */
    overflow: hidden;
    background: linear-gradient(135deg, #FFDEE9 0%, #B5FFFC 100%);
    font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
    touch-action: none; /* Prevents scrolling */
    display: flex;
    flex-direction: column;
    user-select: none;
    -webkit-user-select: none;
  }

  /* --- HEADER --- */
  header {
    height: 10%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 20px;
  }
  
  h1 { font-size: 1.2rem; color: #555; margin: 0; }
  .score-board { 
    background: white; padding: 5px 15px; 
    border-radius: 15px; font-weight: bold; color: #333; 
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
  }

  /* --- GAME AREA (Takes remaining space) --- */
  .game-area {
    height: 90%;
    display: flex;
    flex-direction: column;
    justify-content: space-evenly; /* Spreads Top and Bottom rows apart */
    align-items: center;
    padding-bottom: 20px;
  }

  /* --- ROWS --- */
  .row {
    display: flex;
    justify-content: center;
    gap: 15px; /* Space between items */
    width: 100%;
  }

  /* --- TARGETS (Top Boxes) --- */
  .target {
    width: 28vw; height: 28vw; /* Responsive squares */
    max-width: 110px; max-height: 110px;
    border: 3px dashed #888;
    border-radius: 15px;
    background-color: rgba(255,255,255,0.4);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 3rem;
    opacity: 0.5;
    transition: transform 0.2s;
  }
  .target.highlight { background: #fff; transform: scale(1.1); border-color: #333; }
  .target.matched { 
    border: 3px solid #4CAF50; background: white; opacity: 1; 
    transform: scale(1.05); box-shadow: 0 5px 15px rgba(0,0,0,0.2);
  }

  /* --- SLOTS & ITEMS (Bottom Circles) --- */
  /* The Slot is the "Home" for the item */
  .slot {
    width: 26vw; height: 26vw;
    max-width: 100px; max-height: 100px;
    background: rgba(0,0,0,0.1); /* Dark circle placeholder */
    border-radius: 50%;
    position: relative; /* CRITICAL: Item sits inside this relative to it */
  }

  /* The Item sits INSIDE the slot by default */
  .item {
    width: 100%; height: 100%; /* Fill the slot completely */
    position: absolute; /* Lock to the slot */
    top: 0; left: 0;
    background: white;
    border-radius: 50%;
    box-shadow: 0 5px 10px rgba(0,0,0,0.2);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 3.5rem;
    cursor: grab;
    z-index: 10;
  }

  /* When we drag, we switch to this class */
  .item.dragging {
    position: fixed; /* Break out of the slot */
    z-index: 1000;
    pointer-events: none; /* Helps touch events pass through to check collision */
    box-shadow: 0 15px 30px rgba(0,0,0,0.3);
    transform: scale(1.2);
  }

  /* --- POPUP --- */
  #level-msg {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: white; padding: 20px 40px;
    border-radius: 20px; font-size: 2rem;
    box-shadow: 0 0 50px rgba(0,0,0,0.2);
    z-index: 2000; transition: transform 0.3s;
  }
  #level-msg.show { transform: translate(-50%, -50%) scale(1); }
  
  canvas { position: fixed; top: 0; left: 0; pointer-events: none; z-index: 1500; }
</style>
</head>
<body>

  <header>
    <h1>Match 3!</h1>
    <div class="score-board">Score: <span id="score">0</span></div>
  </header>

  <div class="game-area">
    <div class="row" id="targets-container"></div>
    
    <div class="row" id="slots-container"></div>
  </div>

  <div id="level-msg">Great Job! ðŸŽ‰</div>
  <canvas id="confetti"></canvas>

<script>
// --- DATA (Over 100 items mixed) ---
const DATA = [
  {id:'lion',i:'ðŸ¦'},{id:'dog',i:'ðŸ¶'},{id:'cat',i:'ðŸ±'},{id:'bear',i:'ðŸ»'},{id:'panda',i:'ðŸ¼'},
  {id:'pig',i:'ðŸ·'},{id:'frog',i:'ðŸ¸'},{id:'octo',i:'ðŸ™'},{id:'turtle',i:'ðŸ¢'},{id:'bee',i:'ðŸ'},
  {id:'apple',i:'ðŸŽ'},{id:'banana',i:'ðŸŒ'},{id:'grapes',i:'ðŸ‡'},{id:'pizza',i:'ðŸ•'},{id:'burger',i:'ðŸ”'},
  {id:'car',i:'ðŸš—'},{id:'bus',i:'ðŸšŒ'},{id:'rocket',i:'ðŸš€'},{id:'ship',i:'ðŸš¢'},{id:'train',i:'ðŸš‚'},
  {id:'sun',i:'â˜€ï¸'},{id:'moon',i:'ðŸŒ™'},{id:'star',i:'â­'},{id:'ball',i:'âš½'},{id:'flower',i:'ðŸŒ»'},
  {id:'fox',i:'ðŸ¦Š'},{id:'mouse',i:'ðŸ­'},{id:'bunny',i:'ðŸ°'},{id:'koala',i:'ðŸ¨'},{id:'tiger',i:'ðŸ¯'},
  {id:'cow',i:'ðŸ®'},{id:'chick',i:'ðŸ¤'},{id:'whale',i:'ðŸ³'},{id:'fish',i:'ðŸ '},{id:'crab',i:'ðŸ¦€'},
  {id:'corn',i:'ðŸŒ½'},{id:'carrot',i:'ðŸ¥•'},{id:'fries',i:'ðŸŸ'},{id:'egg',i:'ðŸ¥š'},{id:'cookie',i:'ðŸª'},
  {id:'choco',i:'ðŸ«'},{id:'candy',i:'ðŸ¬'},{id:'cake',i:'ðŸ°'},{id:'donut',i:'ðŸ©'},{id:'ice',i:'ðŸ¦'},
  {id:'police',i:'ðŸš“'},{id:'fire',i:'ðŸš’'},{id:'taxi',i:'ðŸš•'},{id:'bike',i:'ðŸš²'},{id:'plane',i:'âœˆï¸'},
  {id:'tree',i:'ðŸŒ²'},{id:'leaf',i:'ðŸ'},{id:'rose',i:'ðŸŒ¹'},{id:'cactus',i:'ðŸŒµ'},{id:'palm',i:'ðŸŒ´'},
  {id:'gift',i:'ðŸŽ'},{id:'bell',i:'ðŸ””'},{id:'music',i:'ðŸŽµ'},{id:'heart',i:'â¤ï¸'},{id:'gem',i:'ðŸ’Ž'},
  {id:'book',i:'ðŸ§±'},{id:'bulb',i:'ðŸ’¡'},{id:'phone',i:'ðŸ“±'},{id:'tv',i:'ðŸ“º'},{id:'key',i:'ðŸ”‘'}
];

// --- STATE ---
let score = 0;
let matchesLeft = 0;
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// --- INIT LEVEL ---
function initLevel() {
  const targetsDiv = document.getElementById('targets-container');
  const slotsDiv = document.getElementById('slots-container');
  const msgDiv = document.getElementById('level-msg');
  
  targetsDiv.innerHTML = '';
  slotsDiv.innerHTML = '';
  msgDiv.classList.remove('show');
  
  // Pick 3 random
  const shuffled = [...DATA].sort(() => 0.5 - Math.random());
  const levelItems = shuffled.slice(0, 3);
  matchesLeft = 3;

  // 1. Create Targets
  levelItems.forEach(item => {
    const t = document.createElement('div');
    t.className = 'target';
    t.id = `target-${item.id}`;
    t.innerText = item.i;
    targetsDiv.appendChild(t);
  });

  // 2. Create Slots & Items (Shuffled)
  const dragItems = [...levelItems].sort(() => 0.5 - Math.random());
  
  dragItems.forEach(item => {
    // Create the container slot
    const slot = document.createElement('div');
    slot.className = 'slot';
    
    // Create the item INSIDE the slot
    const drag = document.createElement('div');
    drag.className = 'item';
    drag.id = `drag-${item.id}`;
    drag.dataset.id = item.id;
    drag.innerText = item.i;

    // Attach Logic
    enableTouchLogic(drag, slot);

    slot.appendChild(drag);
    slotsDiv.appendChild(slot);
  });
}

// --- TOUCH LOGIC (The Fixed Version) ---
function enableTouchLogic(el, homeSlot) {
  
  function onStart(e) {
    e.preventDefault(); // Stop scrolling
    if(audioCtx.state === 'suspended') audioCtx.resume();

    const touch = e.touches ? e.touches[0] : e;
    
    // 1. Calculate current size/position
    const rect = el.getBoundingClientRect();
    
    // 2. Freeze dimensions (so it doesn't shrink when moved to body)
    el.style.width = rect.width + 'px';
    el.style.height = rect.height + 'px';
    
    // 3. Set position to fixed at current location
    el.style.left = rect.left + 'px';
    el.style.top = rect.top + 'px';
    
    // 4. Add 'dragging' class (changes to position: fixed)
    el.classList.add('dragging');
    
    // 5. Move to body so it floats over everything
    document.body.appendChild(el);
    
    // 6. Correction offset (center under finger)
    el.dataset.offsetX = touch.clientX - rect.left;
    el.dataset.offsetY = touch.clientY - rect.top;
  }

  function onMove(e) {
    if(!el.classList.contains('dragging')) return;
    e.preventDefault();
    
    const touch = e.touches ? e.touches[0] : e;
    
    // Move element
    // We lift it slightly (-50px) so the user can see what they are dragging
    const x = touch.clientX - (parseFloat(el.style.width)/2);
    const y = touch.clientY - (parseFloat(el.style.height)/2) - 50;
    
    el.style.left = x + 'px';
    el.style.top = y + 'px';

    // Highlight Check
    const target = document.getElementById(`target-${el.dataset.id}`);
    if(target && isColliding(el, target)) {
      target.classList.add('highlight');
    } else {
      document.querySelectorAll('.target').forEach(t => t.classList.remove('highlight'));
    }
  }

  function onEnd(e) {
    if(!el.classList.contains('dragging')) return;
    
    const target = document.getElementById(`target-${el.dataset.id}`);
    const isMatch = target && isColliding(el, target);

    if (isMatch) {
      // SUCCESS
      target.classList.remove('highlight');
      target.classList.add('matched');
      playPop();
      spawnConfetti(target.getBoundingClientRect());
      el.remove(); // Remove draggable
      
      matchesLeft--;
      if(matchesLeft === 0) levelComplete();
    } else {
      // FAIL - Return to home
      document.querySelectorAll('.target').forEach(t => t.classList.remove('highlight'));
      
      // Get home slot position again (in case screen resized)
      const homeRect = homeSlot.getBoundingClientRect();
      
      // Animate back
      el.style.transition = 'all 0.3s ease';
      el.style.left = homeRect.left + 'px';
      el.style.top = homeRect.top + 'px';
      el.style.transform = 'scale(1)'; // Remove pop effect

      // After animation, put it back in the box structure
      setTimeout(() => {
        el.classList.remove('dragging');
        el.style.transition = '';
        el.style.width = '100%';
        el.style.height = '100%';
        el.style.left = '0';
        el.style.top = '0';
        el.style.position = 'absolute'; // Reset to CSS default
        homeSlot.appendChild(el);
      }, 300);
    }
  }

  // Listeners
  el.addEventListener('touchstart', onStart, {passive:false});
  el.addEventListener('touchmove', onMove, {passive:false});
  el.addEventListener('touchend', onEnd);
  
  el.addEventListener('mousedown', onStart);
  window.addEventListener('mousemove', onMove); // Window listener prevents losing drag
  window.addEventListener('mouseup', onEnd);
}

// --- UTILS ---
function isColliding(el1, el2) {
  const r1 = el1.getBoundingClientRect();
  const r2 = el2.getBoundingClientRect();
  const dist = Math.hypot(
    (r1.left + r1.width/2) - (r2.left + r2.width/2),
    (r1.top + r1.height/2) - (r2.top + r2.height/2)
  );
  return dist < 60; // Sensitivity
}

function levelComplete() {
  score += 10;
  document.getElementById('score').innerText = score;
  document.getElementById('level-msg').classList.add('show');
  playWin();
  spawnConfetti({left: window.innerWidth/2, top: window.innerHeight/2, width:0, height:0}, 100);
  setTimeout(initLevel, 2000);
}

// --- FX ---
function playPop() {
  const o = audioCtx.createOscillator(); 
  const g = audioCtx.createGain();
  o.connect(g); g.connect(audioCtx.destination);
  o.frequency.value = 600; 
  o.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
  g.gain.setValueAtTime(0.1, audioCtx.currentTime); 
  g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
  o.start(); o.stop(audioCtx.currentTime + 0.1);
}

function playWin() {
  [400, 500, 600].forEach((f, i) => {
    setTimeout(() => {
      const o = audioCtx.createOscillator(); 
      const g = audioCtx.createGain();
      o.connect(g); g.connect(audioCtx.destination);
      o.frequency.value = f; 
      g.gain.setValueAtTime(0.1, audioCtx.currentTime);
      g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
      o.start(); o.stop(audioCtx.currentTime + 0.3);
    }, i*100);
  });
}

// Confetti
const cvs = document.getElementById('confetti');
const ctx = cvs.getContext('2d');
cvs.width = window.innerWidth; cvs.height = window.innerHeight;
let parts = [];

function spawnConfetti(rect, count=20) {
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  for(let i=0; i<count; i++) {
    parts.push({
      x: cx, y: cy,
      vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15,
      c: `hsl(${Math.random()*360}, 100%, 50%)`, life: 50
    });
  }
}

function loop() {
  ctx.clearRect(0,0,cvs.width,cvs.height);
  parts.forEach((p, i) => {
    p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life--;
    ctx.fillStyle = p.c; ctx.fillRect(p.x, p.y, 8, 8);
    if(p.life<=0) parts.splice(i,1);
  });
  requestAnimationFrame(loop);
}
loop();

window.addEventListener('resize', () => {
  cvs.width = window.innerWidth; cvs.height = window.innerHeight;
});

// Start
initLevel();
</script>
</body>
</html>
