<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Fun Match</title>
<style>
  /* RESET & BASIC SETUP */
  body {
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden; /* No scrolling allowed */
    background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
    font-family: 'Comic Sans MS', sans-serif;
    touch-action: none; /* KEY: Stops phone from scrolling when you touch */
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* TITLE */
  h1 {
    margin: 15px 0 5px 0;
    font-size: 1.5rem;
    color: #444;
  }

  /* GAME CONTAINER */
  .game-area {
    flex: 1;
    width: 100%;
    display: flex;
    flex-direction: column;
    justify-content: space-evenly;
    align-items: center;
    position: relative;
  }

  /* TARGETS (TOP ROW) */
  .targets-row {
    display: flex;
    justify-content: space-around;
    width: 90%;
  }

  .target {
    width: 120px;
    height: 120px;
    border: 4px dashed #ccc;
    border-radius: 20px;
    background-color: rgba(255,255,255,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 3rem;
    opacity: 0.5; /* Faded look */
    transition: all 0.3s;
    position: relative;
  }

  .target.highlight {
    background-color: #e0f7fa;
    border-color: #26c6da;
    transform: scale(1.1);
  }

  .target.matched {
    border-style: solid;
    border-color: #66bb6a;
    background-color: #fff;
    opacity: 1;
    transform: scale(1.1);
    box-shadow: 0 10px 20px rgba(0,0,0,0.1);
  }

  /* DRAGGABLES (BOTTOM ROW) */
  .draggables-row {
    display: flex;
    justify-content: space-around;
    width: 90%;
    height: 130px; /* Space for items */
  }

  .item {
    width: 100px;
    height: 100px;
    background: white;
    border-radius: 50%;
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 3.5rem;
    cursor: pointer;
    z-index: 100;
    
    /* CRITICAL FOR DRAGGING */
    position: absolute; 
    /* We don't set top/left here, JS handles it */
  }

  /* PLACEHOLDER (Keeps space in the bottom row) */
  .slot {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background: rgba(0,0,0,0.05);
  }

  /* CONFETTI */
  canvas {
    position: fixed;
    top: 0; left: 0;
    pointer-events: none;
    z-index: 9999;
  }

  /* RESTART BUTTON (Hidden usually) */
  #msg {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px 40px;
    border-radius: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    font-size: 2rem;
    display: none;
    z-index: 1000;
    text-align: center;
  }
</style>
</head>
<body>

  <h1>Match the Pictures!</h1>

  <div class="game-area">
    <div class="targets-row" id="targets"></div>
    
    <div class="draggables-row" id="slots">
      </div>
  </div>

  <div id="msg">Good Job! ðŸŽ‰</div>
  <canvas id="confetti"></canvas>

<script>
// --- GAME DATA (Using Emojis for reliability) ---
const DATA = [
  { id: 'lion', icon: 'ðŸ¦' },
  { id: 'monkey', icon: 'ðŸµ' },
  { id: 'dog', icon: 'ðŸ¶' },
  { id: 'cat', icon: 'ðŸ±' },
  { id: 'apple', icon: 'ðŸŽ' },
  { id: 'banana', icon: 'ðŸŒ' },
  { id: 'grapes', icon: 'ðŸ‡' },
  { id: 'car', icon: 'ðŸš—' },
  { id: 'bus', icon: 'ðŸšŒ' },
  { id: 'rocket', icon: 'ðŸš€' },
  { id: 'ball', icon: 'âš½' },
  { id: 'star', icon: 'â­' },
  { id: 'flower', icon: 'ðŸŒ»' },
  { id: 'tree', icon: 'ðŸŒ²' }
];

let currentLevelItems = [];
let matchesLeft = 0;

// --- INIT ---
function initGame() {
  // Pick 2 random items
  const shuffled = [...DATA].sort(() => 0.5 - Math.random());
  currentLevelItems = shuffled.slice(0, 2);
  matchesLeft = 2;

  const targetsDiv = document.getElementById('targets');
  const slotsDiv = document.getElementById('slots');
  targetsDiv.innerHTML = '';
  slotsDiv.innerHTML = '';

  // 1. Create Targets (Drop Zones)
  currentLevelItems.forEach(item => {
    const t = document.createElement('div');
    t.className = 'target';
    t.id = `target-${item.id}`;
    // Show faded emoji as hint
    t.innerText = item.icon; 
    targetsDiv.appendChild(t);
  });

  // 2. Create Draggables (Items)
  // Shuffle them so they don't align perfectly
  const dragItems = [...currentLevelItems].sort(() => 0.5 - Math.random());
  
  dragItems.forEach(item => {
    // Create a "Slot" to hold the place visually
    const slot = document.createElement('div');
    slot.className = 'slot';
    slotsDiv.appendChild(slot);

    // Create the actual Draggable Item
    const drag = document.createElement('div');
    drag.className = 'item';
    drag.id = `drag-${item.id}`;
    drag.innerText = item.icon;
    drag.dataset.id = item.id;
    
    // Position it exactly over the slot initially
    const rect = slot.getBoundingClientRect();
    drag.style.left = rect.left + 'px';
    drag.style.top = rect.top + 'px';

    // Add Touch Logic
    enableDrag(drag, slot);
    
    document.body.appendChild(drag); // Move to body for easier dragging
  });
}

// --- TOUCH LOGIC (The Fix) ---
function enableDrag(el, homeSlot) {
  let startX, startY;
  let initialLeft, initialTop;

  // Function to move element
  function moveAt(pageX, pageY) {
    // Center the item under the finger
    el.style.left = pageX - el.offsetWidth / 2 + 'px';
    el.style.top = pageY - el.offsetHeight / 2 + 'px';
  }

  function onStart(e) {
    // Prevent default to stop scrolling
    e.preventDefault(); 
    const point = e.touches ? e.touches[0] : e;
    
    // Remember start pos in case we need to go back
    const rect = el.getBoundingClientRect();
    initialLeft = rect.left;
    initialTop = rect.top;

    el.style.zIndex = 1000; // Bring to front
    el.style.transform = "scale(1.2)"; // Pop effect
    
    moveAt(point.pageX, point.pageY);
  }

  function onMove(e) {
    e.preventDefault(); // Stop scrolling
    const point = e.touches ? e.touches[0] : e;
    
    // Move slightly above finger (offset -50px) so they can see it
    el.style.left = point.pageX - el.offsetWidth / 2 + 'px';
    el.style.top = (point.pageY - el.offsetHeight / 2) - 50 + 'px'; 

    // Check if near target for highlight
    checkHover(el);
  }

  function onEnd(e) {
    el.style.transform = "scale(1)";
    el.style.zIndex = 100;

    const target = document.getElementById(`target-${el.dataset.id}`);
    
    if (isColliding(el, target)) {
      // SUCCESS!
      snapToTarget(el, target);
    } else {
      // FAIL: Go back home
      el.style.transition = "all 0.3s ease";
      el.style.left = homeSlot.getBoundingClientRect().left + 'px';
      el.style.top = homeSlot.getBoundingClientRect().top + 'px';
      // Remove transition after it lands
      setTimeout(() => el.style.transition = '', 300);
    }

    // Clear highlights
    document.querySelectorAll('.target').forEach(t => t.classList.remove('highlight'));
  }

  // Add Listeners (Both Touch and Mouse)
  el.addEventListener('touchstart', onStart, {passive: false});
  el.addEventListener('touchmove', onMove, {passive: false});
  el.addEventListener('touchend', onEnd);
  
  el.addEventListener('mousedown', onStart);
  document.addEventListener('mousemove', (e) => {
    if(el.style.zIndex == 1000) onMove(e);
  });
  el.addEventListener('mouseup', (e) => {
    if(el.style.zIndex == 1000) onEnd(e);
  });
}

// --- HELPERS ---
function checkHover(dragEl) {
  document.querySelectorAll('.target').forEach(target => {
    if (isColliding(dragEl, target)) {
      target.classList.add('highlight');
    } else {
      target.classList.remove('highlight');
    }
  });
}

function isColliding(el1, el2) {
  const r1 = el1.getBoundingClientRect();
  const r2 = el2.getBoundingClientRect();
  
  // Calculate center points
  const c1x = r1.left + r1.width/2;
  const c1y = r1.top + r1.height/2;
  const c2x = r2.left + r2.width/2;
  const c2y = r2.top + r2.height/2;

  // Distance formula
  const dist = Math.hypot(c1x - c2x, c1y - c2y);
  
  // Snap if within 80 pixels
  return dist < 80;
}

function snapToTarget(el, target) {
  const rect = target.getBoundingClientRect();
  
  // Snap animation
  el.style.transition = "all 0.2s ease";
  el.style.left = rect.left + 'px';
  el.style.top = rect.top + 'px';
  
  // Visual success
  target.classList.add('matched');
  el.remove(); // Remove draggable, target now shows full opacity icon
  
  // Sound
  playSound();
  spawnConfetti(rect.left + rect.width/2, rect.top + rect.height/2);

  matchesLeft--;
  if (matchesLeft === 0) {
    setTimeout(levelComplete, 500);
  }
}

function levelComplete() {
  const msg = document.getElementById('msg');
  msg.style.display = 'block';
  spawnConfetti(window.innerWidth/2, window.innerHeight/2, 50);
  
  // Auto Next after 2 seconds
  setTimeout(() => {
    msg.style.display = 'none';
    initGame();
  }, 2000);
}

// --- SOUND & EFFECTS ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound() {
  if(audioCtx.state === 'suspended') audioCtx.resume();
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.connect(g); g.connect(audioCtx.destination);
  osc.frequency.setValueAtTime(400, audioCtx.currentTime);
  osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.1);
  g.gain.setValueAtTime(0.1, audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
  osc.start(); osc.stop(audioCtx.currentTime + 0.3);
}

// Confetti
const canvas = document.getElementById('confetti');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth; canvas.height = window.innerHeight;
let particles = [];

function spawnConfetti(x, y, count=20) {
  for(let i=0; i<count; i++) {
    particles.push({
      x: x, y: y,
      vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
      life: 50, color: `hsl(${Math.random()*360}, 100%, 50%)`
    });
  }
}
function loop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let i=particles.length-1; i>=0; i--) {
    let p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, 8, 8);
    if(p.life<=0) particles.splice(i,1);
  }
  requestAnimationFrame(loop);
}
loop();

// START
initGame();
</script>
</body>
</html>
